# ç”¨æˆ·ä½“éªŒè®¾è®¡æ–‡æ¡£

## ğŸ“Œ æ–‡æ¡£æ¦‚è¿°

æœ¬æ–‡æ¡£è¯¦ç»†æè¿°ç³»ç»Ÿçš„ç”¨æˆ·ä½“éªŒè®¾è®¡ã€ç•Œé¢äº¤äº’ã€å®æ—¶åé¦ˆæœºåˆ¶å’Œå‰ç«¯æ¶æ„ã€‚

---

## 1. ç”¨æˆ·ç•Œé¢è®¾è®¡

### 1.1 æ•™å¸ˆç«¯ç•Œé¢

#### 1.1.1 ä½œä¸šç®¡ç†é¡µé¢

**å¸ƒå±€ç»“æ„**:
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  å¯¼èˆªæ : é¦–é¡µ | ä½œä¸šç®¡ç† | æ‰¹æ”¹è®°å½• | æ•°æ®åˆ†æ | è®¾ç½®    â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚  ğŸ“ ä½œä¸šåˆ—è¡¨                    [+ åˆ›å»ºä½œä¸š]     â”‚   â”‚
â”‚  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤   â”‚
â”‚  â”‚  ğŸ” æœç´¢: [_____________]  ç­›é€‰: [å…¨éƒ¨â–¼]        â”‚   â”‚
â”‚  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤   â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚   â”‚
â”‚  â”‚  â”‚ ğŸ“„ æ•°å­¦ä½œä¸š - ç¬¬ä¸‰ç« ç»ƒä¹                  â”‚  â”‚   â”‚
â”‚  â”‚  â”‚ æˆªæ­¢: 2025-10-10  æäº¤: 45/50  å¾…æ‰¹: 12  â”‚  â”‚   â”‚
â”‚  â”‚  â”‚ [æŸ¥çœ‹è¯¦æƒ…] [æ‰¹é‡æ‰¹æ”¹] [å¯¼å‡ºæŠ¥å‘Š]         â”‚  â”‚   â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚   â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚   â”‚
â”‚  â”‚  â”‚ ğŸ“„ ç‰©ç†ä½œä¸š - åŠ›å­¦ç»¼åˆ                   â”‚  â”‚   â”‚
â”‚  â”‚  â”‚ æˆªæ­¢: 2025-10-12  æäº¤: 38/50  å¾…æ‰¹: 5   â”‚  â”‚   â”‚
â”‚  â”‚  â”‚ [æŸ¥çœ‹è¯¦æƒ…] [æ‰¹é‡æ‰¹æ”¹] [å¯¼å‡ºæŠ¥å‘Š]         â”‚  â”‚   â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**äº¤äº’æµç¨‹**:
```typescript
// åˆ›å»ºä½œä¸šæµç¨‹
const createAssignmentFlow = {
  step1: {
    title: "åŸºæœ¬ä¿¡æ¯",
    fields: ["æ ‡é¢˜", "æè¿°", "æˆªæ­¢æ—¥æœŸ", "ç­çº§é€‰æ‹©"]
  },
  step2: {
    title: "æ‰¹æ”¹è®¾ç½®",
    fields: ["è¯„åˆ†æ ‡å‡†", "æ‰¹æ”¹æŒ‡ä»¤", "ä¸¥æ ¼ç¨‹åº¦", "æœ€é«˜åˆ†"]
  },
  step3: {
    title: "ç¡®è®¤å‘å¸ƒ",
    preview: true,
    actions: ["ä¿å­˜è‰ç¨¿", "ç«‹å³å‘å¸ƒ"]
  }
}
```

#### 1.1.2 æ‰¹æ”¹ç®¡ç†é¡µé¢

**å®æ—¶æ‰¹æ”¹è¿›åº¦**:
```tsx
interface BatchGradingProgress {
  batchId: string;
  totalCount: number;
  completedCount: number;
  failedCount: number;
  progress: number; // 0-100
  estimatedTimeRemaining: number; // seconds
  status: 'pending' | 'processing' | 'completed' | 'failed';
}

const BatchGradingProgressView: React.FC<{batch: BatchGradingProgress}> = ({batch}) => {
  return (
    <div className="batch-progress-card">
      <div className="progress-header">
        <h3>æ‰¹æ”¹è¿›åº¦</h3>
        <span className="status-badge">{batch.status}</span>
      </div>
      
      {/* è¿›åº¦æ¡ */}
      <div className="progress-bar-container">
        <div 
          className="progress-bar" 
          style={{width: `${batch.progress}%`}}
        />
        <span className="progress-text">{batch.progress}%</span>
      </div>
      
      {/* ç»Ÿè®¡ä¿¡æ¯ */}
      <div className="stats-grid">
        <div className="stat-item">
          <span className="stat-label">æ€»æ•°</span>
          <span className="stat-value">{batch.totalCount}</span>
        </div>
        <div className="stat-item">
          <span className="stat-label">å·²å®Œæˆ</span>
          <span className="stat-value success">{batch.completedCount}</span>
        </div>
        <div className="stat-item">
          <span className="stat-label">å¤±è´¥</span>
          <span className="stat-value error">{batch.failedCount}</span>
        </div>
        <div className="stat-item">
          <span className="stat-label">é¢„è®¡å‰©ä½™</span>
          <span className="stat-value">{formatTime(batch.estimatedTimeRemaining)}</span>
        </div>
      </div>
      
      {/* å®æ—¶æ—¥å¿— */}
      <div className="live-log">
        <h4>å®æ—¶æ—¥å¿—</h4>
        <div className="log-entries">
          {/* WebSocketå®æ—¶æ›´æ–° */}
        </div>
      </div>
    </div>
  );
};
```

#### 1.1.3 æ‰¹æ”¹ç»“æœå®¡æ ¸é¡µé¢

**æ‰¹æ”¹ç»“æœå¡ç‰‡**:
```tsx
interface GradingResultCard {
  submissionId: string;
  studentName: string;
  score: number;
  maxScore: number;
  confidence: number;
  errors: ErrorAnnotation[];
  needsReview: boolean;
}

const GradingResultReviewView: React.FC = () => {
  const [results, setResults] = useState<GradingResultCard[]>([]);
  const [selectedResult, setSelectedResult] = useState<GradingResultCard | null>(null);
  
  return (
    <div className="review-layout">
      {/* å·¦ä¾§åˆ—è¡¨ */}
      <div className="results-list">
        {results.map(result => (
          <div 
            key={result.submissionId}
            className={`result-card ${result.needsReview ? 'needs-review' : ''}`}
            onClick={() => setSelectedResult(result)}
          >
            <div className="student-info">
              <span className="student-name">{result.studentName}</span>
              {result.needsReview && <span className="review-badge">éœ€å®¡æ ¸</span>}
            </div>
            <div className="score-display">
              <span className="score">{result.score}</span>
              <span className="max-score">/ {result.maxScore}</span>
            </div>
            <div className="confidence-bar">
              <div 
                className="confidence-fill" 
                style={{width: `${result.confidence * 100}%`}}
              />
            </div>
          </div>
        ))}
      </div>
      
      {/* å³ä¾§è¯¦æƒ… */}
      <div className="result-detail">
        {selectedResult && (
          <GradingDetailView 
            result={selectedResult}
            onApprove={handleApprove}
            onAdjust={handleAdjust}
            onReject={handleReject}
          />
        )}
      </div>
    </div>
  );
};
```

### 1.2 å­¦ç”Ÿç«¯ç•Œé¢

#### 1.2.1 ä½œä¸šæäº¤é¡µé¢

**æ‹–æ‹½ä¸Šä¼ **:
```tsx
const AssignmentSubmissionView: React.FC<{assignmentId: string}> = ({assignmentId}) => {
  const [files, setFiles] = useState<File[]>([]);
  const [uploading, setUploading] = useState(false);
  const [uploadProgress, setUploadProgress] = useState(0);
  
  const handleDrop = (e: React.DragEvent) => {
    e.preventDefault();
    const droppedFiles = Array.from(e.dataTransfer.files);
    setFiles(prev => [...prev, ...droppedFiles]);
  };
  
  const handleSubmit = async () => {
    setUploading(true);
    
    const formData = new FormData();
    files.forEach(file => formData.append('files', file));
    formData.append('assignment_id', assignmentId);
    
    try {
      await uploadWithProgress(formData, (progress) => {
        setUploadProgress(progress);
      });
      
      toast.success('æäº¤æˆåŠŸ!é¢„è®¡10åˆ†é’Ÿå†…å®Œæˆæ‰¹æ”¹');
      
    } catch (error) {
      toast.error('æäº¤å¤±è´¥,è¯·é‡è¯•');
    } finally {
      setUploading(false);
    }
  };
  
  return (
    <div className="submission-container">
      <div 
        className="dropzone"
        onDrop={handleDrop}
        onDragOver={(e) => e.preventDefault()}
      >
        <div className="dropzone-content">
          <UploadIcon />
          <p>æ‹–æ‹½æ–‡ä»¶åˆ°æ­¤å¤„æˆ–ç‚¹å‡»ä¸Šä¼ </p>
          <p className="hint">æ”¯æŒ JPG, PNG, PDF æ ¼å¼</p>
        </div>
      </div>
      
      {files.length > 0 && (
        <div className="file-list">
          {files.map((file, index) => (
            <div key={index} className="file-item">
              <FileIcon type={file.type} />
              <span className="file-name">{file.name}</span>
              <span className="file-size">{formatFileSize(file.size)}</span>
              <button onClick={() => removeFile(index)}>åˆ é™¤</button>
            </div>
          ))}
        </div>
      )}
      
      {uploading && (
        <div className="upload-progress">
          <div className="progress-bar" style={{width: `${uploadProgress}%`}} />
          <span>{uploadProgress}%</span>
        </div>
      )}
      
      <button 
        className="submit-button"
        onClick={handleSubmit}
        disabled={files.length === 0 || uploading}
      >
        {uploading ? 'æäº¤ä¸­...' : 'æäº¤ä½œä¸š'}
      </button>
    </div>
  );
};
```

#### 1.2.2 æ‰¹æ”¹ç»“æœæŸ¥çœ‹é¡µé¢

**äº¤äº’å¼é”™è¯¯æ ‡æ³¨**:
```tsx
const GradingResultView: React.FC<{submissionId: string}> = ({submissionId}) => {
  const [result, setResult] = useState<GradingResult | null>(null);
  const [displayMode, setDisplayMode] = useState<'coordinate' | 'cropped'>('coordinate');
  const [selectedError, setSelectedError] = useState<ErrorAnnotation | null>(null);
  
  return (
    <div className="grading-result-container">
      {/* å¤´éƒ¨ä¿¡æ¯ */}
      <div className="result-header">
        <div className="score-section">
          <div className="score-circle">
            <span className="score-value">{result?.score}</span>
            <span className="score-max">/ {result?.maxScore}</span>
          </div>
          <div className="score-label">
            {getScoreLabel(result?.score, result?.maxScore)}
          </div>
        </div>
        
        <div className="display-mode-toggle">
          <button 
            className={displayMode === 'coordinate' ? 'active' : ''}
            onClick={() => setDisplayMode('coordinate')}
          >
            åæ ‡æ ‡æ³¨
          </button>
          <button 
            className={displayMode === 'cropped' ? 'active' : ''}
            onClick={() => setDisplayMode('cropped')}
          >
            å±€éƒ¨å›¾å¡ç‰‡
          </button>
        </div>
      </div>
      
      {/* æ‰¹æ”¹å†…å®¹ */}
      <div className="result-content">
        {displayMode === 'coordinate' ? (
          <CoordinateAnnotationView 
            imageUrl={result?.originalImageUrl}
            annotations={result?.annotations}
            onAnnotationClick={setSelectedError}
          />
        ) : (
          <CroppedRegionView 
            errors={result?.errors}
            onErrorClick={setSelectedError}
          />
        )}
      </div>
      
      {/* é”™è¯¯è¯¦æƒ…ä¾§è¾¹æ  */}
      {selectedError && (
        <div className="error-detail-sidebar">
          <h3>é”™è¯¯è¯¦æƒ…</h3>
          <div className="error-type">
            <span className="label">é”™è¯¯ç±»å‹:</span>
            <span className="value">{selectedError.type}</span>
          </div>
          <div className="error-description">
            <span className="label">é”™è¯¯è¯´æ˜:</span>
            <p>{selectedError.description}</p>
          </div>
          <div className="correct-answer">
            <span className="label">æ­£ç¡®ç­”æ¡ˆ:</span>
            <p>{selectedError.correctAnswer}</p>
          </div>
          <div className="knowledge-points">
            <span className="label">ç›¸å…³çŸ¥è¯†ç‚¹:</span>
            <ul>
              {selectedError.knowledgePoints.map((kp, i) => (
                <li key={i}>{kp}</li>
              ))}
            </ul>
          </div>
          <div className="suggestions">
            <span className="label">æ”¹è¿›å»ºè®®:</span>
            <p>{selectedError.suggestion}</p>
          </div>
        </div>
      )}
      
      {/* æ€»ä½“åé¦ˆ */}
      <div className="overall-feedback">
        <h3>æ€»ä½“è¯„ä»·</h3>
        <p>{result?.overallComment}</p>
        
        <div className="strengths-weaknesses">
          <div className="strengths">
            <h4>âœ… ä¼˜ç‚¹</h4>
            <ul>
              {result?.strengths.map((s, i) => <li key={i}>{s}</li>)}
            </ul>
          </div>
          <div className="weaknesses">
            <h4>âš ï¸ éœ€è¦æ”¹è¿›</h4>
            <ul>
              {result?.weaknesses.map((w, i) => <li key={i}>{w}</li>)}
            </ul>
          </div>
        </div>
      </div>
    </div>
  );
};
```

---

## 2. å®æ—¶åé¦ˆæœºåˆ¶

### 2.1 WebSocketé€šä¿¡

**è¿æ¥ç®¡ç†**:
```typescript
class WebSocketManager {
  private ws: WebSocket | null = null;
  private reconnectAttempts = 0;
  private maxReconnectAttempts = 5;
  private reconnectDelay = 1000;
  private messageHandlers: Map<string, (data: any) => void> = new Map();
  
  connect(userId: string) {
    const wsUrl = `${WS_BASE_URL}/ws/${userId}`;
    this.ws = new WebSocket(wsUrl);
    
    this.ws.onopen = () => {
      console.log('WebSocket connected');
      this.reconnectAttempts = 0;
    };
    
    this.ws.onmessage = (event) => {
      const message = JSON.parse(event.data);
      this.handleMessage(message);
    };
    
    this.ws.onclose = () => {
      console.log('WebSocket disconnected');
      this.attemptReconnect(userId);
    };
    
    this.ws.onerror = (error) => {
      console.error('WebSocket error:', error);
    };
  }
  
  private handleMessage(message: WebSocketMessage) {
    const handler = this.messageHandlers.get(message.type);
    if (handler) {
      handler(message.data);
    }
  }
  
  subscribe(messageType: string, handler: (data: any) => void) {
    this.messageHandlers.set(messageType, handler);
  }
  
  send(type: string, data: any) {
    if (this.ws && this.ws.readyState === WebSocket.OPEN) {
      this.ws.send(JSON.stringify({ type, data }));
    }
  }
  
  private attemptReconnect(userId: string) {
    if (this.reconnectAttempts < this.maxReconnectAttempts) {
      this.reconnectAttempts++;
      const delay = this.reconnectDelay * Math.pow(2, this.reconnectAttempts - 1);
      
      setTimeout(() => {
        console.log(`Reconnecting... (attempt ${this.reconnectAttempts})`);
        this.connect(userId);
      }, delay);
    }
  }
  
  disconnect() {
    if (this.ws) {
      this.ws.close();
      this.ws = null;
    }
  }
}

// ä½¿ç”¨
const wsManager = new WebSocketManager();

// è®¢é˜…æ‰¹æ”¹è¿›åº¦æ›´æ–°
wsManager.subscribe('grading_progress', (data) => {
  updateGradingProgress(data);
});

// è®¢é˜…æ‰¹æ”¹å®Œæˆé€šçŸ¥
wsManager.subscribe('grading_completed', (data) => {
  showNotification('æ‰¹æ”¹å®Œæˆ', data.message);
  refreshGradingResults();
});
```

### 2.2 è¿›åº¦è¿½è¸ª

**å®æ—¶è¿›åº¦ç»„ä»¶**:
```tsx
const RealTimeProgressTracker: React.FC<{taskId: string}> = ({taskId}) => {
  const [progress, setProgress] = useState<TaskProgress>({
    status: 'pending',
    progress: 0,
    currentStep: '',
    message: ''
  });
  
  useEffect(() => {
    // è®¢é˜…è¿›åº¦æ›´æ–°
    const unsubscribe = wsManager.subscribe('task_progress', (data) => {
      if (data.taskId === taskId) {
        setProgress(data);
      }
    });
    
    return () => unsubscribe();
  }, [taskId]);
  
  return (
    <div className="progress-tracker">
      <div className="progress-steps">
        <Step 
          name="é¢„å¤„ç†" 
          status={getStepStatus('preprocess', progress.currentStep)}
          icon={<FileIcon />}
        />
        <Step 
          name="AIæ‰¹æ”¹" 
          status={getStepStatus('grading', progress.currentStep)}
          icon={<BrainIcon />}
        />
        <Step 
          name="è´¨é‡å®¡æ ¸" 
          status={getStepStatus('review', progress.currentStep)}
          icon={<CheckIcon />}
        />
        <Step 
          name="ç”Ÿæˆåé¦ˆ" 
          status={getStepStatus('feedback', progress.currentStep)}
          icon={<MessageIcon />}
        />
      </div>
      
      <div className="progress-bar">
        <div 
          className="progress-fill"
          style={{width: `${progress.progress}%`}}
        />
      </div>
      
      <div className="progress-message">
        {progress.message}
      </div>
    </div>
  );
};
```

### 2.3 é€šçŸ¥ç³»ç»Ÿ

**å¤šæ¸ é“é€šçŸ¥**:
```typescript
interface Notification {
  id: string;
  type: 'success' | 'info' | 'warning' | 'error';
  title: string;
  message: string;
  timestamp: Date;
  read: boolean;
  actionUrl?: string;
}

class NotificationManager {
  private notifications: Notification[] = [];
  private listeners: ((notifications: Notification[]) => void)[] = [];
  
  // æ·»åŠ é€šçŸ¥
  add(notification: Omit<Notification, 'id' | 'timestamp' | 'read'>) {
    const newNotification: Notification = {
      ...notification,
      id: uuid(),
      timestamp: new Date(),
      read: false
    };
    
    this.notifications.unshift(newNotification);
    this.notify();
    
    // æ˜¾ç¤ºToast
    this.showToast(newNotification);
    
    // æµè§ˆå™¨é€šçŸ¥
    if (Notification.permission === 'granted') {
      new Notification(newNotification.title, {
        body: newNotification.message,
        icon: '/icon.png'
      });
    }
  }
  
  // æ ‡è®°ä¸ºå·²è¯»
  markAsRead(id: string) {
    const notification = this.notifications.find(n => n.id === id);
    if (notification) {
      notification.read = true;
      this.notify();
    }
  }
  
  // è·å–æœªè¯»æ•°é‡
  getUnreadCount(): number {
    return this.notifications.filter(n => !n.read).length;
  }
  
  // è®¢é˜…é€šçŸ¥å˜åŒ–
  subscribe(listener: (notifications: Notification[]) => void) {
    this.listeners.push(listener);
    return () => {
      this.listeners = this.listeners.filter(l => l !== listener);
    };
  }
  
  private notify() {
    this.listeners.forEach(listener => listener(this.notifications));
  }
  
  private showToast(notification: Notification) {
    toast[notification.type](notification.message, {
      duration: 5000,
      position: 'top-right'
    });
  }
}

// ä½¿ç”¨
const notificationManager = new NotificationManager();

// WebSocketæ¥æ”¶é€šçŸ¥
wsManager.subscribe('notification', (data) => {
  notificationManager.add({
    type: data.type,
    title: data.title,
    message: data.message,
    actionUrl: data.actionUrl
  });
});
```

---

## 3. å“åº”å¼è®¾è®¡

### 3.1 ç§»åŠ¨ç«¯é€‚é…

**å“åº”å¼å¸ƒå±€**:
```scss
// æ–­ç‚¹å®šä¹‰
$breakpoints: (
  'mobile': 320px,
  'tablet': 768px,
  'desktop': 1024px,
  'wide': 1440px
);

// å“åº”å¼Mixin
@mixin respond-to($breakpoint) {
  @media (min-width: map-get($breakpoints, $breakpoint)) {
    @content;
  }
}

// ä½¿ç”¨
.grading-result-container {
  display: flex;
  flex-direction: column;
  
  @include respond-to('tablet') {
    flex-direction: row;
  }
  
  .result-content {
    width: 100%;
    
    @include respond-to('tablet') {
      width: 70%;
    }
  }
  
  .error-detail-sidebar {
    width: 100%;
    margin-top: 20px;
    
    @include respond-to('tablet') {
      width: 30%;
      margin-top: 0;
      margin-left: 20px;
    }
  }
}
```

### 3.2 è§¦æ‘¸ä¼˜åŒ–

**æ‰‹åŠ¿æ”¯æŒ**:
```typescript
const useTouchGestures = (elementRef: React.RefObject<HTMLElement>) => {
  const [touchStart, setTouchStart] = useState<{x: number, y: number} | null>(null);
  const [scale, setScale] = useState(1);
  
  useEffect(() => {
    const element = elementRef.current;
    if (!element) return;
    
    // ç¼©æ”¾æ‰‹åŠ¿
    const handleTouchStart = (e: TouchEvent) => {
      if (e.touches.length === 2) {
        const touch1 = e.touches[0];
        const touch2 = e.touches[1];
        const distance = Math.hypot(
          touch2.clientX - touch1.clientX,
          touch2.clientY - touch1.clientY
        );
        setTouchStart({x: distance, y: scale});
      }
    };
    
    const handleTouchMove = (e: TouchEvent) => {
      if (e.touches.length === 2 && touchStart) {
        const touch1 = e.touches[0];
        const touch2 = e.touches[1];
        const distance = Math.hypot(
          touch2.clientX - touch1.clientX,
          touch2.clientY - touch1.clientY
        );
        const newScale = touchStart.y * (distance / touchStart.x);
        setScale(Math.max(0.5, Math.min(3, newScale)));
      }
    };
    
    element.addEventListener('touchstart', handleTouchStart);
    element.addEventListener('touchmove', handleTouchMove);
    
    return () => {
      element.removeEventListener('touchstart', handleTouchStart);
      element.removeEventListener('touchmove', handleTouchMove);
    };
  }, [elementRef, touchStart]);
  
  return { scale };
};
```

---

## 4. æ€§èƒ½ä¼˜åŒ–

### 4.1 è™šæ‹Ÿæ»šåŠ¨

**å¤§åˆ—è¡¨ä¼˜åŒ–**:
```tsx
import { FixedSizeList } from 'react-window';

const VirtualizedResultList: React.FC<{results: GradingResult[]}> = ({results}) => {
  const Row = ({ index, style }: { index: number; style: React.CSSProperties }) => (
    <div style={style} className="result-row">
      <GradingResultCard result={results[index]} />
    </div>
  );
  
  return (
    <FixedSizeList
      height={600}
      itemCount={results.length}
      itemSize={120}
      width="100%"
    >
      {Row}
    </FixedSizeList>
  );
};
```

### 4.2 å›¾ç‰‡æ‡’åŠ è½½

```tsx
const LazyImage: React.FC<{src: string, alt: string}> = ({src, alt}) => {
  const [imageSrc, setImageSrc] = useState<string | null>(null);
  const imgRef = useRef<HTMLImageElement>(null);
  
  useEffect(() => {
    const observer = new IntersectionObserver(
      (entries) => {
        entries.forEach(entry => {
          if (entry.isIntersecting) {
            setImageSrc(src);
            observer.disconnect();
          }
        });
      },
      { threshold: 0.1 }
    );
    
    if (imgRef.current) {
      observer.observe(imgRef.current);
    }
    
    return () => observer.disconnect();
  }, [src]);
  
  return (
    <img 
      ref={imgRef}
      src={imageSrc || '/placeholder.png'}
      alt={alt}
      className="lazy-image"
    />
  );
};
```

---

**ä¸‹ä¸€æ­¥**: æŸ¥çœ‹ `06_FRONTEND_MOCK_IMPLEMENTATION.md` äº†è§£å‰ç«¯Mockå®ç°

